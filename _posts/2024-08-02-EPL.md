---
title: Escalar Privilegios en Linux
layout: post
post-image: "../assets/images/Labs/EPL/p.png"
description: Módulo sobre las diferentes formas de escalar privilegios en un sistema Linux.
enlace: https://tryhackme.com/r/room/linprivesc
difficulty: Media
tags: 
  - LAB
---
# Escalar Privilegios en Linux


Escalar privilegios consiste en explotar una vulnerabilidad del sistema para ganar acceso no autorizado desde una cuenta con pocos permisos (privilegios) a una con mayor número de los mismos, siendo el *root* aquella cuenta la cual tiene todos los permisos en el sistema.

Mediante estos procesos podemos realizar varias tareas como:

- Resetear contraseñas.
- Saltar el control del acceso a datos protegidos.
- Habilitar la persistencia.
- Modificar la configuración del sistema.
- Cambiar los privilegios de los usuarios.

# Enumeración

La enumeración es el primer paso para poder ganar acceso a cualquier sistema. Como hemos comentado antes, mediante la explotación de una vulnerabilidad critica del sistema podemos acceder a una cuenta con altos privilegios o incluso a una cuenta  de superusaurio (root). Para ello debemos de conocer algunos métodos de enumeración:

## Hostname

El comando <code>hostname</code>  nos devuelve el nombre de la máquina objetivo que en ocasiones nos puede devolver información útil para conocer el rol de la maquina en la red.

## Uname -a

Con el comando <code>uname -a</code> vamos a poder imprimir por pantalla información adicional sobre el kernel que está usando el sistema. Esto es muy útil para poder buscar *vulnerabilidades a nivel kernel*, para poder escalar privilegios.

## /proc/version

Si miramos en el directorio <code>/proc/version</code> podremos ver la versión del kernel y datos adicionales, además el sistema de archivos proc (*procfs*) nos ofrece información sobre los procesos del sistema destino.

## /etc/issue

El sistema también puede ser identificado si consultamos el archivo <code>/etc/issue</code>, el cual contiene información sobre el S.O pero esto se puede personalizar o cambiar fácilmente.

## Comando ps y pspy

El comando <code>ps</code>  nos muestra todos los procesos en ejecución en el sistema Linux, donde se muestra lo siguiente:

- PID: ID del proceso.
- TTY: Tipo de terminal utilizado.
- Time: Cantidad de tiempo de uso de CPU.
- CMD: Comando o ejecutable que está corriendo.

Este comando nos ofrece varias opciones como es el caso de <code>ps -A</code> donde vemos todos los procesos ó <code>ps aux</code> donde muestra los procesos de todos los usuarios (a), el comando que lanza el proceso (u), y muestra procesos que no están ligados a la terminal (x).

Viendo la salida del comando ps, podemos entender de mejor manera el sistema y las posibles vulnerabilidades que pueden haber en él.

Sin embargo, el comando <code>ps</code> puede que no nos muestre algunos procesos deseados, por tanto, para ello haremos uso de <code>pspy</code> 

## Comando env

El comando <code>env</code> nos muestra las *environmental variables* (variables de entorno):

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


La variable <code>*PATH*</code> es la ruta que utiliza el shell para realizar la ejecución de comandos y ejecutables (sin tener que especificar la ruta), si la alteramos a nuestro favor, podremos acceder a ficheros sin tener los privilegios necesarios para hacerlo de forma normal.

## Comando sudo-l

Con el comando <code>sudo -l</code> podemos listar los comando que puede hacer uso el usuario para convertirse en usuario root, es decir, lista de comandos que el usuario puede ejecutar usando *sudo.*

Esto no implica que siempre se ejecuten como root, si no que pueden dar permisos para ejecutar archivos como <code>www-data</code>.

## Comando ls

Este comando <code>ls</code> nos permite listar los archivos y directorio, es uno de los más comunes, pero a la hora de escalar privilegios es muy útil ya que nos puede ayudar a buscar archivos o directorios que están ocultos, esto lo podemos hacer mediante el comando <code>ls -la</code>.

En este ejemplo vemos como haciendo uso de <code>ls</code> no nos muestra nada pero si hacemos uso de <code>ls -la</code> encontramos un archivo llamado *secret.txt*.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 1.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


## Comando Id

Con el este comando, podemos obtener información sobre el nivel de privilegios de un grupo de usuarios o del usuario.

## /etc/passwd

En el archivo del directorio <code>/etc/passwd</code> vamos a encontrar todos los usuarios del sistema.

Si hacemos un <code>cat /etc/passwd</code> obtendremos como salida:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 2.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Podemos hacerlo más legible y usarlo como una lista para un ataque de fuerza bruta haciendo <code>cat /etc/passwd | cut -d ":" -f 1</code> , donde cortamos desde los “:” y solamente nos quedamos con la primera columna:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 3.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

## Comando history

Si escribimos <code>history</code> en la terminal esta nos devolverá los inputs que se le han hecho anteriormente a la terminal, donde podremos encontrar información privilegiada.

## Comando ifconfig

Puede ser que nuestra máquina objetivo esté pivotando a otra red, por lo que con el uso del comando <code>ifconfig</code> podremos ver información sobre las interfaces red de la máquina. 

## Comando netstat

Con <code>netstat</code> podremos comprobar las interfaces de red y rutas existentes de una máquina, mediante <code>netstat -a</code> podremos ver todos los puertos de escucha abiertos y conexiones establecidas, con <code>netstat -at</code> (conexiones TCP), <code>netstat -au</code> (conexiones UDP) y con <code>nestat -l</code> listamos los puertos que están en modo escucha.

Con <code>nestat -s</code> listamos las estadísticas del uso de la red para cada protocolo, podemos especificar el protocolo con <code>-t</code> (TCP) ó <code>-u</code> (UDP).

## Comando find

Este comando es muy útil para poder buscar binarios con el bit SUID activado que pueden ser ejecutados por el usuario para escalar privilegios. Podemos hacer uso de “</code>2> /dev/null</code>” para que los errores los redireccionen a */dev/null*  y solo nos muestre los resultados sin errores.

Para realizar una búsqueda sería de la forma → <code>find / -type f -name <nombre_archivo> 2>/dev/null</code>, con la opción ’</code>f</code>’ estamos buscando ficheros, con un nombre determinado desde la raíz ‘</code>/</code>’

Como hemos comentado podemos hacer uso de find para la búsqueda de binarios con el bit SUID activado, para escalar privilegios, para ello, haríamos uso de <code>find / -perm -4000 2>/dev/null</code> ó <code>find / -perm -4000 -type f -exec ls -ld {} \; 2>/dev/null</code>,donde para cada archivo (fichero) <code>f</code> que busque tirará el comando <code>ls -ld</code> donde <code>{}</code> se reemplaza por el nombre de cada archivo y <code>\;</code> indica el fin del comando <code>-exec</code>.

Esta segunda es una búsqueda más completa debido a que nos puede ayudar a la hora de buscar el binario para ejecutar la vulnerabilidad.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 4.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


# Escalar Privilegios: Exploits del kernel de Linux

El kernel en Linux gestiona las comunicaciones entre los diferentes componentes como la memoria del sistema y las aplicaciones.

Cualquiera de estas funciones tiene que tener los suficientes permisos para que se puedan llevar a cabo, por tanto, explotar una vulnerabilidad de este tipo nos otorgará permisos de root.

La metodología a seguir es:

1. Identificar la versión del kernel.
2. Buscar y encontrar un exploit para dicha versión del kernel.
3. Ejecutar el exploit.

Aunque esto parece muy simple, si el kernel falla se producirá un crash en el sistema.

### Ejemplo práctico:

Para identificar el kernel del sistema linux vamos a hacer uso del comando → <code>uname -a</code> 

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 5.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Después del nombre *wade7363* encontramos la versión del kernel del sistema, si buscamos en Google algún CVE sobre dicha versión del kernel encontramos → [Exploit-DB](https://www.exploit-db.com/exploits/37292)

Aquí encontramos un script que nos permite explotar el kernel del sistema, para ello:

Primero de todo nos situamos en el directorio /tmp de **nuesta máquina** → <code>cd /tmp</code>  y creamos un fichero cuya extensión sea .c → <code>touch exploit.c</code>

A continuación copiamos el código del exploit y lo pegamos en nuestro fichero creado con <code>touch</code> 

Mediante el comando <code>python3 -m http.server 8080</code> creamos un servidor y en la máquina víctima hacemos uso del comando <code>wget</code> :

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 6.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Se realiza la conexión y se descarga el archivo en la máquina víctima

Nos cambiamos al directorio /tmp en la máquina víctima y hacemos <code>wget</code> 

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 7.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Ahora compilamos el script con <code>gcc nombre_arcivho.c -o nombre_archivo</code> para poder ejecutarlo de la forma <code>./nombre_archivo</code> 

En nuestro caso será:

Procedemos a compilar el archivo:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 8.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Vemos como ahora tenemos un ejecutable y el archivo con extensión .c

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 9.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Ahora lo ejecutamos mediante <code>./exploit</code>

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 10.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Vemos que ya hemos escalado privilegios a root, y ahora podemos hacer lo que queramos en el sistema.

# Escalar Privilegios: Sudo

Por defecto, el comando <code>sudo</code> nos permite la ejecución de programas y comandos a nivel de root. 

Como hemos visto anteriormente, mediante el uso del comando <code>sudo -l</code> podemos listar todos los comandos que puede ejecutar el usuario con privilegios de root.

Para poder aprovecharnos de esto, buscamos en [GTFOBins](https://gtfobins.github.io/) exploit del comando que nos dice que tenemos permisos de ejecutar.

En la vida real no todo se encuentra en GTObins o ExploitDB, por tanto, lo que podemos hacer es encontrar otras maneras como:

1. Verificar las configuraciones de Sudo → A veces la configuración de sudo en <code>/etc/sudoers</code> es incorrecta permitiendo a usuarios no autorizados poder ejecutar comando como root sin contraseña
2. Explotar vulnerabilidades de Software → Puede darse el caso de que el sistema tiene software vulnerable instalado que puede ser explotado para escalar privilegios.

### Ejemplo práctico:

Tenemos una máquina víctima, mediante <code>sudo -l</code> podemos ver los comando que puede ejecutar el usuario, en este caso el usuario *karen*, como root.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 11.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Vemos que puede hacer uso de varios comandos como root. Podemos usar cualquiera de los 3, asi que vamos a elegir el <code>/usr/bin/find</code>. Ahora nos vamos a [GTFOBins - SUDO](https://gtfobins.github.io/gtfobins/find/#sudo) para consultar información sobre como escalar privilegios y los ponemos en práctica:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 12.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Finalmente, hemos escalado privilegios a root.

# Escalar Privilegios: SUID

Como hemos visto arriba, mediante el comando <code>find / -perm -4000 -type f -exec ls -ld{} \; 2>/dev/null</code> podemos conocer los archivos que tienen activado el bit SUID para poder escalar privilegios.

Dependiendo del binario, podemos o bien convertirnos en usuarios con permisos root ó ejecutar comando que requieren de permisos root pero sin que el usuario actual los tenga (podemos verlo en el ejemplo práctico).

Tras haber realizado la búsqueda podemos buscar en [GTFOBins](https://gtfobins.github.io/) exploits dependiendo del binario a explotar, por ejemplo en el *ejemplo práctico* vemos que tenemos un binario <code>/usr/bin/base64</code>, por tanto buscaremos en dicha web el exploit SUID de base64.

### Ejemplo práctico:

Por ejemplo, si encontramos el binario base64 con bit SUID activado podemos hacer uso de su exploit para acceder a fichero los cuales hace falta ser root como <code>/etc/passwd</code> (usuarios del sistema) ó <code>/etc/shadow</code> (contraseñas del sistema).
<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 13.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Buscamos en https://gtfobins.github.io/ el exploit de bit SUID de base64 y vemos que si ejecutamos <code>LFILE =file_to_read</code> y luego <code>./base64 "$LFILE" | base64 --decode</code> podemos abrir ambos ficheros (especificándolos en *file_to_read*) sin tener permisos de root.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 14.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Contenido de <code>/etc/shadow</code>

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 15.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Contenido de <code>/etc/passwd</code>

Mediante esto, en nuestra máquina podemos crear dos ficheros nuevos llamados, por ejemplo **users.txt** (contenido de <code>/etc/passwd</code>) y **passwords.txt** (contenido de <code>/etc/shadow</code>) y mandarlos a un nuevo fichero para desencriptar las contraseñas:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 16.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Y ahora vamos a desencriptarlas mediante el uso de **JohnTheRipper** haciendo uso de un diccionario de contraseñas (*rockyou.txt*):

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 17.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Y como resultado tenemos la contraseñas:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 18.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


# Escalar Privilegios: Capabilities

Otro método que los administradores de sistemas pueden usar para escalar el privilegio de un proceso o binario es las “Capabilities”, estas nos ayudan a gestionar permisos concretos a las aplicaciones para que se ejecuten sin tener que darles todos los permisos.

Comando <code>getcap -r / 2>/dev/null</code>.

Si nos encontramos algún lenguaje de programación podemos investigar para poder escalar privilegios, por tanto, si esto ocurre, vamos de nuevo a [GTFOBins](https://gtfobins.github.io/) para buscar exploits en el apartado C*apabilities.*

Si hacemos uso del comando anterior vamos a listar las *Capabilities* del sistema y por ejemplo nos encontramos:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 19.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Encontramos que 6 binarios tienen activas las *Capabilities*, los más interesantes son <code>/home/karen/vim</code> y <code>/home/ubuntu/view</code>.

Como nuestra flag se encuentra en <code>/home/ubuntu</code> y no podemos acceder ya que la flag tiene permisos root, tendremos que buscar una manera de poder acceder al fichero.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 20.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


 En https://gtfobins.github.io/gtfobins/view/#capabilities podemos buscar información sobre el binario a explotar para poder acceder a la flag, pero si hacemos uso del comando <code>/home/ubuntu/view /home/ubuntu/flag4.txt</code> tenemos acceso a la flag explotando el binario <code>/home/ubuntu/view</code> sin tener que convertirnos en root.

Podemos hacer uso de cualquiera de los dos binarios con las *Capabilities* activadas para poder acceder al fichero de la flag.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 21.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Ejemplo con el binario view

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 22.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Ejemplo con el binario vim

# Escalar Privilegios: Tareas Cron

Los *Cron Jobs* se utilizan para ejecutar binarios o scripts en un momento específico. Por defecto, pueden ejecutarlos con los permisos de sus propietario y no con los del usuario actual.

Gracias a esto, si encontramos una tarea con privilegios root, podemos cambiar el script que ejecuta dicha tarea para que la nuestra se ejecute con privilegios root.

Si hacemos un <code>cat /etc/crontab</code> podemos ver las tareas cron programadas del sistema, pero pueden haber tareas que mediante <code>cron</code> no pueden ser leídas, para eso podemos hacer uso de <code>pspy</code> .

Esta escalada de privilegio se realizan mediante una **reverse_shell**, por tanto, el fichero a modificar será un **.sh** donde sobrescribiremos el contenido del mismo por el código de la reverse_shell.

### Ejemplo práctico:

Tenemos una máquina víctima. Como hemos visto arriba mediante el comando <code>cat /etc/crontab</code> podemos ver los comandos y ejecutables que están programados.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 23.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Si nos fijamos bien, encontramos un fichero llamado **/home/karen/backup.sh** este tiene permisos root. Para poder escalar privilegios mediante esta manera tenemos que modificar dicho archivo y convertirlo en una reverse_shell.

En [RevShells](https://www.revshells.com/) podemos generar la reverse_shell que vamos a utilizar, para ello necesitamos conocer la ip pública de nuestra máquina → <code>ifconfig</code> → **tun0** y esta debe de ser de tipo **Bash**.

Incluimos en el fichero [**backup.sh**](http://backup.sh) la reverse_shell con <code>nano</code> .

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 24.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Ahora le damos permisos de ejecución:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 25.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Vemos que se ha producido la reverse_shell y estamos dentro como root:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 26.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


# Escalar Privilegios: PATH Hijacking

Los comandos en Linux se ejecutan desde la izquierda a la derecha, por tanto, si colamos un archivo malicioso en dicha ruta se ejecutará sin problema.

 Si hacemos un  <code>echo $PATH</code> vamos a obtener la ruta que sigue el sistema para buscar los ejecutables y scripts, es decir busca dichos ejecutables sin tener que especificar toda la ruta.

Para ellos hacemos:

<ol>
  <li>Creamos un fichero con la extensión .c, es decir un fichero con código en c →  <code>touch archivo.c</code></li>
  <li>Ahora introducimos el código malicioso poniendo tanto el  <code>suid</code> como  <code>sgid</code> a 0:</li>
</ol>

<div style="text-align:center;">
  <div class="code-container">
    <div class="code-header">
    C
    <button class="copy-button" onclick="copyToClipboard()">Copiar</button>
      </div>
      <pre><code class="language-C" >#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(){
  setuid(0); //Establece el ID de usuario a 0 (root).
  setgid(0); //Establece el ID de grupo a 0 (root).
  system("/bin/bash"); //Ejercuta una shell
  return 0;
}</code></pre>
            </div>
          </div>

Luego, de crear el script vamos a:
<ol>
  <li>Mediante  <code>gcc</code> vamos a compilarlo para que se convierta en ejecutable dicho binario →  <code>gcc archivo.c -o archivo</code>.</li>
  <li>Ahora mediante  <code>chmod +s archivo</code> vamos a dar asignarle permiso SUID, esto hará que se ejecute como root.</li>
  <li>Ahora exportamos el directorio donde se encuentra dicho binario al PATH →  <code>export PATH=&lt;ruta_del_binario&gt;:$PATH</code></li>
  <li>A continuación incluimos “/bin/bash” dentro del binario del PATH →  <code>echo "/bin/bash" &gt; archivo</code> (si previamente lo hemos hecho podemos saltárnoslo) y le damos todos los permisos  <code>chmod 777 archivo</code>.</li>
  <li>Finalmente, mediante  <code>./archivo</code> ejecutamos el binario y escalamos privilegios.</li>
</ol>

Por tanto, no nos hace falta realizar una búsqueda de binarios con bit SUID, podemos crear un archivo malicioso nosotros, activando el bit SUID y mediante un código malicioso (lanzar una Shell, por ejemplo) escalar privilegios ejecutando otro comando diferente ya que este estará contenido en el la variable de entorno PATH.

### Ejemplo práctico:

Vamos a proceder a realizar un PATH Hijacking, para ello, primero vamos a echarle un ojo al PATH

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 27.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


En esta ruta podemos colar un binario que tenga el bit SUID activado para poder escalar privilegios → <code>find / -perm -4000 -ls 2>/dev/null</code>

Encontramos estos ficheros, pero el que nos interesa es el último de todos, debido a que se encuentra en el directorio <code>/home</code> , es decir <code>/home/murdoch/test</code>

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 28.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Ahora vamos a exportar dicha ruta al PATH → <code>*export PATH=/home/murdoch:$PATH*</code> y si hacemos <code>echo $PATH</code> vemos que ha cambiado:

<div style="text-align: center; ">
  <img src="../assets/images/Labs/EPL/Untitled 29.png" alt="Untitled" onclick="openModal(this.src)"/>
</div>


A continuación nos cambiamos al directorio del fichero con el bit SUID activado → <code>cd /home/murdoch/test</code> y si hacemos un <code>cat</code>al fichero <code>thm.py</code> podemos ver su contenido

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 30.png" alt="Untitled" onclick="openModal(this.src)"/>
</div>


Donde pone <code>os.system("thm")</code> tenemos que sustituir '<em>thm</em>' por '<em>/bin/bash</em>', para ello hacemos uso del comando <code>echo "/bin/bash" >> thm</code>, le cambiamos los permisos a 'todos' y ejecutamos:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 31.png" alt="Untitled" onclick="openModal(this.src)"/>
</div>

Finalmente, vemos que hemos escalado privilegios secuestrando el PATH.


# Escalar Privilegios: NFS

Los vectores de escalada de privilegios no solo se encuentran en el acceso interno, los archivos compartidos e interfaces de gestión remota como SSH o Telnet también nos pueden ayudar para conseguir acceso root en el sistema objetivo.

La configuración NFS (Network File Sharing) se encuentra en el archivo  <code>/etc/exports</code>, el cual se crea durante la instalación del servidor NFS y generalmente pueden ser leídos por los usuarios del sistema.

Si hacemos un  <code>cat /etc/exports</code> encontramos la información sobre la configuración NFS:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 32.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


El elemento crítico aquí es la opción “ <code>no_root_squash</code>” (se puede ver arriba). 

En NFS, cuando un usuario cliente accede a un directorio compartido / exportado por el servidor NFS, los permisos del cliente se mapean a los permisos del servidor. Por defecto, NFS trata de manera especial a los usuarios root (por seguridad) donde con la opción “**root_squash**” convierte a dicho usuario root en un usuario sin privilegios dentro del servidor NFS.

Por tanto, si encontramos un directorio compartido sin esta opción de configuración, el servidor NFS permitiría que los usuarios que tienen permisos de root en el sistema cliente, también tenga dichos permisos en dicho servidor.

Por tanto, si esta opción ( “no_root_squash” ) está presente en un recurso compartido y encima escribible, podemos crear un ejecutable con el bit SUID y ejecutarlo en el sistema objetivo, haciendo que tengamos control total de los archivos y directorios del servidor NFS.

Para ello, en la máquina objetivo hacemos:

<ol>
  <li>Primero enumeramos las monturas de nuestra máquina →  <code>showmount -e &lt;ip_maquina_victima&gt;</code></li>
  <li>Creamos una montura <strong>no_root_squash</strong> →  <code>mkdir /tmp/nombre_montura</code></li>
  <li>La montamos →  <code>mount -o rw &lt;nuestra_ip&gt;:/backups /tmp/nombre_montura</code></li>
  <li>Escribimos el script malicioso dentro del directorio que hemos compartido:
    Creamos este script en C, donde hacemos lo siguiente:
<table>
  <tr>
    <td style="vertical-align:top;">
      <div style="text-align: center; ">
        <img src="../assets/images/Labs/EPL/Untitled 33.png" alt="Untitled" onclick="openModal(this.src)" style="width:100%; max-width:300px"/>
      </div>
    </td>
    <td style="vertical-align:top;">
      <ol>
        <li> <code>setgid(0)</code> → Indicamos el ID del grupo a 0 (root).</li>
        <li> <code>setuid(0)</code> → Indicamos el ID del user a 0 (root).</li>
        <li> <code>system("/bin/bash")</code> → Lanzamos una shell de Bash.</li>
      </ol>
    </td>
  </tr>
</table></li>

<li>Compilamos el script → <code>gcc nfs.c -o nfs -w</code>, y luego le activamos el bit SUID <code>chmod +s nfs</code> para que se pueda ejecutar como root.</li>
</ol>

### Ejemplo práctico:

Tenemos una máquina víctima con la ip **10.10.58.32**, donde mediante el comando  <code>cat /etc/exports</code> vemos que directorios están compartidos y contienen la opción “no_root_squash, por tanto podemos usar cualquiera de los directorios que están compartidos.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 34.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Como queremos compartir un directorio con dicho servidor que contenga un script malicioso, primero vamos a enumerar los directorios compartidos de la máquina victima.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 35.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Ahora vamos a crear un nuevo directorio (siendo root) en nuestro directorio <code>/tmp</code> (ya que tenemos todos los permisos) y luego montamos “compartimos” dicho directorio con alguno de la máquina víctima. Yo en este ejemplo seleccioné el directorio <code>/home/ubuntu/sharedfolder</code> debido a que podía cambiarme a dicho directorio siendo un usuario sin permisos root.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 36.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Tras haber compartido el directorio, vamos a crear un fichero con extensión <code>.c</code> (un script en el lenguaje de programación C):

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 37.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Dentro escribimos lo siguiente →

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 38.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Creamos este script en C, donde hacemos lo siguiente:
<ol>
  <li><code>setgid(0)</code> → Indicamos el ID del grupo a 0 (root).</li>
  <li><code>setuid(0)</code> → Indicamos el ID del user a 0 (root).</li>
  <li><code>system("/bin/bash")</code> → Lanzamos una Shell de Bash.</li>
</ol>

Luego de haber escrito el archivo con extensión <code>.c</code> tenemos que convertirlo en un ejecutable, para ello hacemos uso del compilador <code>gcc</code> que mediante la opción <code>-o archivo</code> convierte el script en un binario con el nombre archivo.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 39.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Tras haber obtenido el binario, activamos el bit SUID del mismo

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 40.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Si accedemos desde la máquina víctima al directorio compartido (en mi caso es <code>/home/ubuntu/sharedfolder</code>, como dije anteriormente) y si hacemos un listado con <code>ls</code> vemos que tenemos tanto el archivo con extensión <code>.c</code> como el <code>binario</code>.


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 41.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Finalmente, si ejecutamos el binario mediante <code>./eploit</code> veremos que se ejecuta una Shell root, es decir, escalaremos privilegios y seremos root dentro del servidor NFS.

# Capstone Challenge

Consiste en un reto que nos propone el laboratorio donde tenemos que obtener dos *flags* y para ello tenemos que escalar privilegios dentro de una máquina la cual nos conectamos de manera remota con <code>ssh</code>.

Iniciamos sesión mediante las credenciales <em>leonard:Penny123</em> → <code>ssh leonard@<ip_maquina_victima></code> 


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 42.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 43.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Vamos a buscar los binarios con SUID activados, para poder aprovecharnos de esto ya que nos permiten en algunos casos escalar a privilegios root ó ejecutar comando sin tener los privilegios necesarios.


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 44.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Vamos a intentar explotar el binario <code>/usr/bin/base64</code>para leer los ficheros <code>passwd</code> y <code>shadow</code> (este no se puede ver con <code>cat</code>, ya que requiere de permisos root), por eso realizamos su lectura mediante el exploit del binario de base64, es decir, podemos leer el contenido del fichero <code>/etc/shadow</code> sin que el usuario actual “*leonard*” tenga permisos root.

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 45.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Contenido de <code>/etc/passwd</code> (usuarios del sistema) que vamos a guardar en el fichero <code>users.txt</code>


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 46.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Contenido de <code>/etc/shadow</code> (contraseñas de cada usuario) que vamos a guardar en el fichero <code>pass.txt</code>


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 47.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Creamos los ficheros <code>users.txt</code> y <code>pass.txt</code> para almacenar el contenido de los ficheros <code>passwd</code> y <code>shadow</code> del directorio <code>/etc</code>.

Luego escribimos en cada uno de ellos el contenido de los ficheros (copiar y pegar).

Mediante <code>unshadow</code> combinamos el contenido de ambos ficheros y lo guardamos en uno nuevo llamado <code>contraseñas.txt</code> el cual usaremos para descifrar las contraseñas hasheadas.

Hacemos uso de JohnTheRipper para poder descifrar las contraseñas de cada usuario:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 48.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Encontramos un usuario llamado *missy* y su contraseña:

<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 49.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


vamos a iniciar sesión con esas credenciales y buscamos las flags:


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 50.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>

Ahora vamos a buscar una manera de conseguir privilegios root. Vamos a intentar ver si *missy* puede ejecutar algún comando como sudo → <code>sudo -l</code>


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 51.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


En efecto, hemos encontrado que podemos hacer uso de <code>/usr/bin/find</code> así que buscamos la manera de activar el exploit para ejecutar una Shell como root:


<div style="text-align: center; ">
    <img src="../assets/images/Labs/EPL/Untitled 51.png" alt="Untitled" onclick="openModal(this.src)"/>
  </div>


Conseguimos la segunda flag, habiendo escalado privilegios haciendo uso de un comando que el usuario actual “*missy*” puede ejecutar como sudo. 

---